Есть несколько способов выборки лексем из входного потока.
Строковое представление лексемы помещается в TokenString, 
массив в 256 символов. Значение лексемы выбирается из перечислимого
типа TTokenType, или TTokenValue. Значение перечислителя 
помещается в переменную TokenValue. Buffer указывает на буфер 
со сканируемым текстом, BufPtr - текущий указатель в буфере,
Всегда указывает на начало следующей лексемы. TokenPtr и TokenEnd
тип указатель на char указывают в буфере начало и конец данной 
лексемы соответственно. Значение TokenPtr получается после
пропуска пробелов и установки на первый непробельный символ.

При каждом обращении к функции, выбирающей лексемы, сначала
происходит пропуск пробелов, установка TokenPtr на начало лексемы.
Далее анализируется первый символ. Если это цифра, то лексема
является цифровым литералом, если это буква или подчерк, то это
идентификатор или ключевое слово, иначе это может быть специальный
символ. Специальный символ может быть лексемой операции, такой как
"+" или "-", или пунктуатором, например, ";" или ",". Лексема 
операции может состоять из нескольких символов : ">=", "+=" и т.д.

Для получения значения односимвольной лексемы можно использовать
массив размером в 256 элементов типа TTokenType, со значениями,
соответствующими данной лексеме. Символ используется как индекс
в массиве. Остальные позиции занимают нулевые значени, или ttEof 
в перечислителе. Сначала получается значение из массива. Потом
далется просмотр первого символа для многосимвольных лексем.
Указатель буфера увеличивается и проверяется следующий за данным
символ. Иногда за данным может следовать несколько символов, 
поэтому надо перебрать все возможные значения. Это делается 
с помощью условного оператора или оператора выбора. 

Альтернативой этому является большой оператор выбора с 
присваиваниями для каждого случая.

Если первый символ кавычка или двойная кавычка, то это символ 
или строка, соответственно. 

После выборки лексемы указатель TokenEnd устанавливается равным
текущему указателю в буфере, т.е. на конец лексемы. Строка 
копируется из TokenPtr в TokenString. Если надо, преобразовывается 
к верхнему регистру. Для строковых констант заносится длина строки
в LenString.

Если лексема - идентификатор или ключевое слово, просматривается
таблица имен. Если это ключевое слово, значение его помещается
в TokenValue. Если идентификатор - Ident устанавливается равным
найденному идентификатору или nil, если имя не найдено.

Операции присваивания вычисляются - если за лексемой операции
следует "=", то это сокращенная операция присваивания. Значения
лексем операций и присваиваний идут последовательно.

Для разбора выражений используется просто рекурсивный спуск. 
Имеется 9 функций с первого по девятый уровень Level1 .. Level9.
Выбор первичных выражени проивзодится на 9 уровне. Level9 просто
помещает значение выражения - числового литерала, булевской 
константы или идентификатора на стек. Индексация строки и векторов
также выполнятеся на этом уровне. На стек помещается значение
элемента вектора или строки. Осущетсвляется вызов встроенной 
функции или функци определеяемой пользователем.

Префиксный инкремент осущетсвляет функция Level8. Если встречается
лексема инкремента, то выполняются такие действия. Запоминается
операция, выбирается следующая лексема, это должен быть
идетификатор (переменная), инкремент или декремент, затем 
вызывается Level9, который помещает изменное значение переменной
на стек. 

Постфиксный инкремент/декремент реализуется иначе. Запоминается
укзатель на идентификатор, если он есть, вызывается level9, 
помещающий значение переменной на стек, при возврате в Level8 
проверяется значение лексемы - если это инк или дек, выполняется
операция над запомненным идентификатором.

Операции присваивания, которые можно использовать  в выражениях,
каскадировать труднее релаизовать, так как они ассоциируются 
справа налево и имеют самый низкий приоритет.

Допустим, у нас есть функция Level0, вызываемая самой первой
для разбора выражения. Перед разбором выражения, естественно,
выбирается первая лексема. Если эта лексема - имя, то оно 
запоминается, выбирается следующая лексема. Если следующая лексема
 является операцией присваивания, выбирается следующая и level0 
рекурсивно вызывает сама себя. Если первая на входе лексема 
не имя, то вызывается level1 для простого разбора выражения.
А если лексема после имени не операция присваивания? Тогда
приходится возвращать лексему назад. Для этого надо сохранить
состоние - PrevToken:= TokenValue; PrevBuf:= TokenPtr; - 
значение лексемы и указатель на начало лексемы и восстановить его.
Но для индексации это не подходит. Простой просмотр вперед в поисках
операции присваивания невозможен, так как используются 
сокращенные операции присваивания и индексация.

Возведение в степень тоже можно сделать правоассоциативной -
сначала вызов нижнего уровня, если текущая лексема - операция
степени, выбрать следующую лексему, вызывать себя, выполнить
возведение в степень. Первый вызов Level1 поместит на стек
значение идентификатора, выберет следуюущую лексему, которая
не будет обработана и поднимется наверх до Level0. Но если 
используется индексация, то на стек будет помещено значение
элемента массива с заданным индексом, который будет уже разобран
и использовать его будет невозможно.

Еще одно решение - ввести внутренний тип указателя, состоящий
из нетипизированного указателя и информации о типе значения,
на который он указывает. Адресный тип.





На самом верху находятся логические операции, входами для
них являются операции отношения - сравнения и проверки на 
равенство, имеющие одинаковый приоритет. Арифметические операции
имеют обычный приоритет, аддитивные, мультипликативные и степень.
Самый высокий приоритет имеют унарные плюс и минус и префиксный и 
постфиксный инкремент и декремент. Битовые операции имеют 
приоритеты, схожие с другими - битовое И и сдвиги имеют приоритет
операций типа умножения, битовые ИЛИ и исключающее ИЛИ - приоритет
операций типа сложения.

- унарный , изменение знака
+ унарный , изменение знака
++ префиксный , инкремент, 
-- префиксный , декремент
++ постфиксный инкремент
-- постфиксный декремент
~  битовое НЕ

** степень

* умножение 
% остаток от деления 
/ деление 
\  целое деление 
& битовое И
<< сдвиг влево
>> сдвиг вправо

+ плюс
- минус
| битовое ИЛИ
^ битовое исключающее ИЛИ

<  меньше, чем
<=, =< меньше или равно
= равно
<>, !=, >< не равно
>=, => больше или равно
> больше, чем

! - логическое отрицание
&& логическое И
|| логическое ИЛИ
^^ логическое исключающее ИЛИ

некоторым операциям соответствуют ключевые слова
%   - mod
\   - div
&&  - and
||  - or
^^  - xor
!   - NOT
<<  - shl
>>  - shr


логические операции вычисляются полностью
инкремент и декремент можно использовать только в выражениях

для назначения переменной значения применяется оператор 
присваивания вида
переменная := выражение
можно использовать сокращенные присваивания
x += y : сложить и присвоить x:=x + y
x -= y : вычесть и присвоить x:= x - y
x *= y : умножить и присвоить x:= x * y
x \= y : разделить нацело и присвоить x := x div y
x /= y : разделить и присвоить x:= x / y
x %= y : присвоить остаток от деления x := x % y
x |= y :  x := x | y
x <<= y : x := x << y
x >>= y : x := x >> y
x &= y :  x := x & y
x ^= y :  x := x ^ y
x **= y : x := x ** y

сокращаенные присваивания могут использоваться только в операторах 
присваивания












Оператор ::= 
             Присваивание | 
             Обращение к процедуре/фукнции |
             Условный оператор|
             Цикл с предусловием|
             Цикл с постусловием |
             Цикл с параметром |
             Описание

Описание ::=
       Описание переменной |
       Описание функции

Описание переменной ::= 
       Описание простой переменной |
       Описание массива

Описание массива ::=
       имя_Типа 
       VECTOR | MATRIX | ARRAY 
       идентификатор
       [константное выражение] 
       ;

Описание простой переменной 
       Имя Типа идентификатор  
       [:= выражение] 
        ;


Описание фукнции ::= 
       DEFUN Тип_Возврата идентефикатор 
       "("[список формальных параметров] ")" ";"
       
              
Цикл с параметром ::= 
       FOR <имя>:= Выражение_ОТ TO Выражение_ДО 
       [STEP Выражение_ШАГ] DO СписокОператоров NEXT;
Цикл с предусловием ::=
       WHILE Выражение DO СписокОператоров WEND;
Цикл с постусловием ::= 
       REPEAT СписокОператоров UNTIL Выражение ;
Условный оператор :: =
       IF выражение THEN СписокОператоров 
      [ ELSE  СписокОператоров] 
      ENDIF ;
ОператорПрисваивания ::=
    <имя> := Выражение ;
Обращение к процедуре/функции ::= 
    <имя>[(Список аргументов)]  ;

Список_Операторов ::=
     Оператор {"," Оператор}

Список аргументов ::=
    "("[Список выражений]")"


Список выражений ::= Выражение {"," Выражение}

Выражение ::= 
        ЛогическоеВыражение []
Логическое выражение ::= 
        Логическое И
Логическое И ::=
        Логическое НЕ
Логическое НЕ ::=
        Релятивное выражение
Релятивное выражение ::=
        Арифметическое выражение
Арифметическое выражение ::=
        Терм
Терм ::=    
        Субтерм
Субтерм ::=
       Унарное выражение
Унарное выражение ::=
       Первичное выражение
Первичное выражение ::=
       Имя | Вызов функции |  
       индексное выражение / 
       "(" Выражение ")"  /
       константное выражение


   
        
        
