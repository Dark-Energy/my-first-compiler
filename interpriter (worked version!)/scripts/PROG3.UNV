/* алгоритм Евклида нахождения наибольшего общего делителя 
одновременно не равных нулю целых чисел  a, b, a>=b>0. 

Пусть а и b - одновременно не равные нулю целые числа и пусть а>=b.
Тогда, если b=0, то НОД (a,b)= а, а если b<>0, то для чисел a, b и с, где
с - остаток от деления а на b, выполнено равенство 
НОД(a,b)= НОД(b,c). Например, НОД(15, 6) = НОД(6,3)= НОД(3,0)=3.
*/

/*
int a:=15, b:=6,c:=0;
if b= 0 then c:=a; endif;
while b>0 do 
  c:=a mod b; a:=b; b:=c;
wend;
Write(a);
*/

/* нахождение суммы 1+1/2+..1/n;*/
/*
int i, n:=7; 
real s:=0;
for i:= 1 to n do 
   s:=s+1/i;
next;
Write(s);
*/

/*
int a:= 5**10;
int b:= 5**2 * 5**2 * 5**2 * 5**2 * 5**2;
if a=b then Write(true); endif;

int c:= 5*5;  //5**2
int d:= c*c;  //5**2 * 5**2 = 5**4
Write(d);
int e:= d*d;  // 5**4 * 5**4 = 5**8
Write(e);
int f:= e*c;   //5**8 * 5**2 = 5*(8+2)=5**10
 Write(f); 
Write(a);
*/

/*
int a:=4, b:= 6;
if (a**2+b**2)/4 = a**2/4+b**2/4 then 
    Write(True) else Write(False); endif;
*/


/* дробная часть f представляется с помощью k-1 цифры в десятичном
виде, т.е. таким массивом d, что 
  f = Si: 1<=i<k: di  * 10** -i

Предположим, что мы хотим разделить d на 2. Это проделывается 
повторением знакомой операции деления всех k-1цифр  di, начиная с
i:=1. Операция включает деление каждой цифры на 2 с учетом
возможного "переноса" из предыдущей позиции и переноса 
возможного остатка r в следующую позицию. 

 r:= 10 * r + d[i];    d[i]:= r div 2;    r:= r mod 2;
*/


int N:=10;
int  i, k,  r;
int vector d[N];
//for i:=0 to n-1 do  d[i]:= 0; next;

for k:= 0 to N-1 do 
Write(".");
  r:=0;
  for i:= 0 to k-1 do 
    r:= 10*r + d[i]; 
    d[i]:= r div 2;
    r:= r mod 2;
    Write(chr(d[i]+'0'));
next;
 d[k]:=5;  Writeln("5");
next;

/* 2 в 0 степени это 1
   2 в -1 степени - это 1/2, т.е. 0.5
  внутренний цикл при этом не выполняется
  5 присваивается первому элементу вектора
*/  
end.

Write("fuck");


